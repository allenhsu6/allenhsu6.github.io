<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>策略解析 | Xu'Log</title><meta name=keywords content><meta name=description content><meta name=author content><link rel=canonical href=https://allenhsu6.github.io/categories/%E7%AD%96%E7%95%A5%E8%A7%A3%E6%9E%90/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://allenhsu6.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://allenhsu6.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://allenhsu6.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://allenhsu6.github.io/apple-touch-icon.png><link rel=mask-icon href=https://allenhsu6.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://allenhsu6.github.io/categories/%E7%AD%96%E7%95%A5%E8%A7%A3%E6%9E%90/index.xml title=rss><link rel=alternate hreflang=en href=https://allenhsu6.github.io/categories/%E7%AD%96%E7%95%A5%E8%A7%A3%E6%9E%90/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style><script src=https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js></script><meta property="og:url" content="https://allenhsu6.github.io/categories/%E7%AD%96%E7%95%A5%E8%A7%A3%E6%9E%90/"><meta property="og:site_name" content="Xu'Log"><meta property="og:title" content="策略解析"><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="策略解析"><meta name=twitter:description content></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://allenhsu6.github.io/ accesskey=h title="Xu'Log (Alt + H)">Xu'Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://allenhsu6.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://allenhsu6.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://allenhsu6.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://allenhsu6.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://allenhsu6.github.io/viz-tools/ title="Viz Tools"><span>Viz Tools</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://allenhsu6.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://allenhsu6.github.io/categories/>Categories</a></div><h1>策略解析</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>策略解析：BasicSpreadStrategy (基础价差交易)</h2></header><div class=entry-content><p>源码文件：vnpy_spreadtrading.strategies.basic_spread_strategy
1. 策略概述 BasicSpreadStrategy 与其说是一个自动策略，不如说是一个智能执行工具。 它不包含任何指标计算或预测逻辑，而是完全按照用户在参数中指定的固定价格进行挂单交易。它适合那些通过主观判断或外部计算得出目标价差，然后希望程序自动完成“腿A+腿B”复杂下单过程的交易员。
基类：SpreadStrategyTemplate 核心逻辑：固定点位开平 + 时间过滤 适用场景：主观套利、跨期移仓 2. 核心参数 参数名 含义 buy_price 买入开仓触发价 sell_price 卖出平仓触发价 short_price 卖出开仓触发价 cover_price 买入平仓触发价 max_pos 目标持仓量 start_time 每日开始交易时间 (如 “9:00:00”) end_time 每日停止交易时间 (如 “15:00:00”) 3. 策略逻辑详解 3.1 时间过滤器 策略首先检查当前时间是否在允许的交易时段内。如果不在，会强制停止所有正在运行的算法。
1 2 3 4 5 self.update_time = self.spread.datetime.time() if self.update_time &lt; self.start_t or self.update_time >= self.end_t: self.stop_open_algos() self.stop_close_algos() return 3.2 状态机逻辑 策略根据当前的持仓状态 (spread_pos) 决定启动哪种算法。
空仓 (spread_pos == 0)：
检查是否已启动买入算法 (buy_algoid)，若无则启动。 检查是否已启动卖出算法 (short_algoid)，若无则启动。 注意：这里是同时监控双向开仓机会。 持有多头 (spread_pos > 0)：
停止开仓算法。 启动卖出平仓算法 (sell_algoid)，目标价为 sell_price。 持有空头 (spread_pos &lt; 0)：
...</p></div><footer class=entry-footer><span title='2025-05-13 10:00:00 +0800 +0800'>May 13, 2025</span>&nbsp;·&nbsp;<span>1 min</span></footer><a class=entry-link aria-label="post link to 策略解析：BasicSpreadStrategy (基础价差交易)" href=https://allenhsu6.github.io/posts/strategies/basic_spread_strategy/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>策略解析：StatisticalArbitrageStrategy (统计套利)</h2></header><div class=entry-content><p>源码文件：vnpy_spreadtrading.strategies.statistical_arbitrage_strategy
1. 策略概述 StatisticalArbitrageStrategy 是一个经典的 均值回归 (Mean Reversion) 策略，应用于价差交易。 其核心假设是：两个相关性极高的品种（如豆油/棕榈油，螺纹/热卷），它们的价差会围绕一个均值波动。当价差偏离均值过大（突破布林带上轨/下轨）时，大概率会回归。
基类：SpreadStrategyTemplate 核心指标：Bollinger Bands (布林带) 交易逻辑：逆势交易（高抛低吸） 2. 核心参数 参数名 默认值 含义 boll_window 20 布林带均线周期 boll_dev 2 布林带标准差倍数 max_pos 10 最大持仓量 payup 10 算法执行时的超价跳数 interval 5 算法撤单重发间隔(秒) 3. 策略逻辑详解 3.1 K 线合成与指标计算 策略使用 BarGenerator 合成价差的 K 线（注意：是价差本身的 K 线，不是单腿的）。 在 on_spread_bar 中计算布林带：
1 2 self.boll_mid = self.am.sma(self.boll_window) self.boll_up, self.boll_down = self.am.boll(self.boll_window, self.boll_dev) 3.2 交易信号 策略逻辑非常清晰，分为三种状态：
空仓时 (spread_pos == 0)：
做空价差：价差 > 上轨 (boll_up)。预期价差回归下跌。 做多价差：价差 &lt; 下轨 (boll_down)。预期价差回归上涨。 1 2 3 4 if bar.close_price >= self.boll_up: self.start_short_algo(bar.close_price - 10, self.max_pos, ...) elif bar.close_price &lt;= self.boll_down: self.start_long_algo(bar.close_price + 10, self.max_pos, ...) 持有空头 (spread_pos &lt; 0)：
...</p></div><footer class=entry-footer><span title='2025-05-12 10:00:00 +0800 +0800'>May 12, 2025</span>&nbsp;·&nbsp;<span>1 min</span></footer><a class=entry-link aria-label="post link to 策略解析：StatisticalArbitrageStrategy (统计套利)" href=https://allenhsu6.github.io/posts/strategies/statistical_arbitrage_strategy/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>策略解析：TestStrategy (功能测试工具)</h2></header><div class=entry-content><p>源码文件：vnpy_ctastrategy.strategies.test_strategy
1. 策略概述 TestStrategy 并不是一个用于实盘获利的交易策略，而是一个调试工具。 它的主要作用是帮助开发者验证：
交易接口（Gateway）是否连接正常。 策略引擎（CtaEngine）是否能正确收发订单。 测试下单函数的执行耗时。 基类：CtaTemplate 触发机制：基于 Tick 计数，每隔 N 个 Tick 执行一个测试动作。 2. 测试流程 策略内部维护了一个函数列表 self.test_funcs，按顺序存放了要测试的动作：
市价单测试 (test_market_order)： 以涨停价 (limit_up) 发出买单，模拟市价成交（在期货中通常用对手价或超价模拟市价）。 限价单测试 (test_limit_order)： 以跌停价 (limit_down) 发出买单，模拟挂单（通常不会立即成交）。 全撤测试 (test_cancel_all)： 调用 cancel_all() 撤销之前挂出的所有未成交订单。 停止单测试 (test_stop_order)： 发出本地停止单（Stop Order），验证策略引擎的触发机制。 3. 核心代码逻辑 在 on_tick 中，每收到 test_trigger (默认10) 个 Tick，就弹出一个测试函数执行，并计算耗时。
1 2 3 4 5 6 7 8 9 10 11 self.tick_count += 1 if self.tick_count >= self.test_trigger: self.tick_count = 0 if self.test_funcs: test_func = self.test_funcs.pop(0) # 取出下一个测试任务 start = time() test_func() # 执行 time_cost = (time() - start) * 1000 # 计算耗时(ms) self.write_log(f"耗时{time_cost}毫秒") 4. 使用场景 当你刚配置好一个新的交易接口（比如连接到一个新的仿真环境），或者修改了底层引擎代码后，可以先运行这个策略：
...</p></div><footer class=entry-footer><span title='2025-05-10 10:00:00 +0800 +0800'>May 10, 2025</span>&nbsp;·&nbsp;<span>1 min</span></footer><a class=entry-link aria-label="post link to 策略解析：TestStrategy (功能测试工具)" href=https://allenhsu6.github.io/posts/strategies/test_strategy/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>策略解析：TurtleSignalStrategy (海龟交易法则)</h2></header><div class=entry-content><p>源码文件：vnpy_ctastrategy.strategies.turtle_signal_strategy
1. 策略概述 TurtleSignalStrategy 是大名鼎鼎的 海龟交易法则 (Turtle Trading Rules) 的完整复现。 它不仅仅是一个简单的突破策略，而是一套完整的资金管理系统，包含了：
入场：唐奇安通道 (Donchian Channel) 突破。 仓位管理：基于 ATR (N值) 的加仓 (Pyramiding)。 止损：基于 ATR 的移动止损。 离场：反向通道突破。 基类：CtaTemplate 核心指标：Donchian Channel, ATR 复杂度：高（涉及分批加仓逻辑） 2. 核心参数 参数名 默认值 含义 entry_window 20 入场通道周期 (20日高点) exit_window 10 离场通道周期 (10日低点) atr_window 20 ATR 计算周期 3. 策略逻辑详解 3.1 信号计算 策略使用 am.donchian 计算唐奇安通道，使用 am.atr 计算波动率 N 值。
1 2 3 self.entry_up, self.entry_down = self.am.donchian(self.entry_window) # 20日 self.exit_up, self.exit_down = self.am.donchian(self.exit_window) # 10日 self.atr_value = self.am.atr(self.atr_window) 3.2 初始入场 当空仓时，在 20 日高点挂买入停止单，在 20 日低点挂卖出停止单。
...</p></div><footer class=entry-footer><span title='2025-05-09 10:00:00 +0800 +0800'>May 9, 2025</span>&nbsp;·&nbsp;<span>2 min</span></footer><a class=entry-link aria-label="post link to 策略解析：TurtleSignalStrategy (海龟交易法则)" href=https://allenhsu6.github.io/posts/strategies/turtle_signal_strategy/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>策略解析：MultiTimeframeStrategy (多周期共振)</h2></header><div class=entry-content><p>源码文件：vnpy_ctastrategy.strategies.multi_timeframe_strategy
1. 策略概述 MultiTimeframeStrategy 展示了如何在 CTA 策略中同时处理两个不同频率的时间序列。 通常策略只关注单一 K 线周期（如 15 分钟），但本策略同时订阅并合成：
15 分钟 K 线：用于判断大趋势（Trend）。 5 分钟 K 线：用于寻找具体的入场点（Timing）。 这种“大周期定方向，小周期找买点”的方法是手工交易中非常经典的多周期共振思路。
基类：CtaTemplate 核心机制：双 BarGenerator (5m + 15m) 核心指标：MA (趋势), RSI (择时) 2. 核心参数 参数名 默认值 含义 rsi_window 14 RSI 计算周期 (基于 5 分钟) rsi_signal 20 RSI 阈值偏移 (50 ± 20) fast_window 5 快线周期 (基于 15 分钟) slow_window 20 慢线周期 (基于 15 分钟) 3. 策略逻辑详解 3.1 双周期 K 线合成 策略在 on_init 中初始化了两个 K 线生成器：
...</p></div><footer class=entry-footer><span title='2025-05-08 10:00:00 +0800 +0800'>May 8, 2025</span>&nbsp;·&nbsp;<span>2 min</span></footer><a class=entry-link aria-label="post link to 策略解析：MultiTimeframeStrategy (多周期共振)" href=https://allenhsu6.github.io/posts/strategies/multi_timeframe_strategy/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>策略解析：KingKeltnerStrategy (肯特纳通道突破)</h2></header><div class=entry-content><p>源码文件：vnpy_ctastrategy.strategies.king_keltner_strategy
1. 策略概述 KingKeltnerStrategy 是一个基于 肯特纳通道 (Keltner Channel) 的趋势突破策略。 肯特纳通道与布林带类似，都是“均线 + 带宽”的结构，但肯特纳通道使用 ATR (平均真实波幅) 来计算带宽，而不是标准差。这使得它对波动率的反应更加平滑。
基类：CtaTemplate 周期：5分钟 K 线 核心指标：Keltner Channel (MA ± N * ATR) 订单管理：OCO (One Cancels Other) —— 双向挂单 2. 核心参数 参数名 默认值 含义 kk_length 11 计算均线和 ATR 的周期 kk_dev 1.6 通道宽度倍数 (MA ± 1.6 * ATR) trailing_percent 0.8 移动止损百分比 3. 策略逻辑详解 3.1 指标计算 策略在 5 分钟 K 线 (on_5min_bar) 上计算通道。
1 self.kk_up, self.kk_down = am.keltner(self.kk_length, self.kk_dev) 上轨 = MA + 1.6 * ATR 下轨 = MA - 1.6 * ATR 3.2 入场逻辑：OCO 双向挂单 这是该策略最独特的实现细节。 当空仓时，策略同时在上方挂买入停止单，在下方挂卖出停止单。
...</p></div><footer class=entry-footer><span title='2025-05-07 10:00:00 +0800 +0800'>May 7, 2025</span>&nbsp;·&nbsp;<span>1 min</span></footer><a class=entry-link aria-label="post link to 策略解析：KingKeltnerStrategy (肯特纳通道突破)" href=https://allenhsu6.github.io/posts/strategies/king_keltner_strategy/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>策略解析：DualThrustStrategy (Dual Thrust 区间突破)</h2></header><div class=entry-content><p>源码文件：vnpy_ctastrategy.strategies.dual_thrust_strategy
1. 策略概述 DualThrustStrategy 是 Michael Chalek 在 20 世纪 80 年代开发的著名策略，曾被 Future Truth 杂志评为最赚钱的策略之一。 它是一个典型的 日内突破策略。核心逻辑是利用前 N 日（这里简化为前 1 日）的最高价、最低价、收盘价计算出一个“波动区间 (Range)”，然后以今日开盘价为锚点，加上/减去这个区间的倍数，形成上轨和下轨。
基类：CtaTemplate 核心逻辑：Range Breakout (区间突破) 交易时段：日内交易，收盘前强制平仓 2. 核心参数 参数名 默认值 含义 k1 0.4 上轨系数 (用于做多) k2 0.6 下轨系数 (用于做空) fixed_size 1 每次下单手数 注意：k1 和 k2 可以不对称。如果 k1 &lt; k2，说明做多更容易触发，适合多头市场；反之适合空头市场。
3. 策略逻辑详解 3.1 计算 Range (波动区间) 策略在每天开盘时（检测到日期变化），利用前一日的数据计算 Range。
1 2 3 4 5 6 7 if last_bar.datetime.date() != bar.datetime.date(): if self.day_high: self.day_range = self.day_high - self.day_low # 前一日振幅 # 计算今日突破轨 self.long_entry = bar.open_price + self.k1 * self.day_range self.short_entry = bar.open_price - self.k2 * self.day_range 上轨 (Long Entry) = 今日开盘价 + K1 * 昨日振幅 下轨 (Short Entry) = 今日开盘价 - K2 * 昨日振幅 3.2 盘中突破交易 在收盘时间 (exit_time, 14:55) 之前，策略持续监控价格是否突破上下轨。
...</p></div><footer class=entry-footer><span title='2025-05-06 10:00:00 +0800 +0800'>May 6, 2025</span>&nbsp;·&nbsp;<span>1 min</span></footer><a class=entry-link aria-label="post link to 策略解析：DualThrustStrategy (Dual Thrust 区间突破)" href=https://allenhsu6.github.io/posts/strategies/dual_thrust_strategy/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>策略解析：DoubleMaStrategy (双均线交叉)</h2></header><div class=entry-content><p>源码文件：vnpy_ctastrategy.strategies.double_ma_strategy
1. 策略概述 DoubleMaStrategy 是量化交易中最经典的入门策略——双均线策略。 逻辑极其简单：快线向上穿过慢线（金叉）做多，快线向下穿过慢线（死叉）做空。虽然简单，但它是理解趋势跟踪逻辑的最佳起点。
基类：CtaTemplate 核心指标：SMA (Simple Moving Average) 交易方式：信号触发后立即市价（或限价）成交 2. 核心参数 参数名 默认值 含义 fast_window 10 快线周期 (如 10 日均线) slow_window 20 慢线周期 (如 20 日均线) 3. 策略逻辑详解 3.1 指标计算 策略计算了两条均线的当前值 (ma0) 和上一根 K 线的值 (ma1)，用于判断交叉。
1 2 3 4 5 6 7 fast_ma = am.sma(self.fast_window, array=True) self.fast_ma0 = fast_ma[-1] # 当前 K 线快线 self.fast_ma1 = fast_ma[-2] # 上一根 K 线快线 slow_ma = am.sma(self.slow_window, array=True) self.slow_ma0 = slow_ma[-1] self.slow_ma1 = slow_ma[-2] 3.2 交叉判断 金叉 (Cross Over)：
上一刻：快线 &lt; 慢线 当前：快线 > 慢线 1 cross_over = self.fast_ma0 > self.slow_ma0 and self.fast_ma1 &lt; self.slow_ma1 死叉 (Cross Below)：
...</p></div><footer class=entry-footer><span title='2025-05-05 10:00:00 +0800 +0800'>May 5, 2025</span>&nbsp;·&nbsp;<span>1 min</span></footer><a class=entry-link aria-label="post link to 策略解析：DoubleMaStrategy (双均线交叉)" href=https://allenhsu6.github.io/posts/strategies/double_ma_strategy/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>策略解析：BollChannelStrategy (布林带通道突破)</h2></header><div class=entry-content><p>源码文件：vnpy_ctastrategy.strategies.boll_channel_strategy
1. 策略概述 BollChannelStrategy 是一个基于 布林带 (Bollinger Bands) 的通道突破策略。 它不仅仅依赖价格突破布林带上下轨，还引入了 CCI (Commodity Channel Index) 作为趋势过滤器，并使用 ATR (Average True Range) 来计算动态的移动止损位。
基类：CtaTemplate 周期：15分钟 K 线 (通过 BarGenerator 合成) 核心指标：Bollinger Bands, CCI, ATR 风控机制：ATR 倍数移动止损 2. 核心参数与变量 参数名 默认值 含义 boll_window 18 布林带均线周期 boll_dev 3.4 布林带标准差倍数（较宽，意味着只抓大趋势） cci_window 10 CCI 计算周期 atr_window 30 ATR 计算周期 sl_multiplier 5.2 止损距离的 ATR 倍数（非常宽的止损） 3. 策略逻辑详解 3.1 K 线合成 策略在 on_init 中初始化了一个 15 分钟的 K 线生成器：
1 self.bg = BarGenerator(self.on_bar, 15, self.on_15min_bar) 这意味着 on_tick 更新 1 分钟 bar，1 分钟 bar 累积满 15 个后触发 on_15min_bar，核心逻辑都在 on_15min_bar 中执行。
...</p></div><footer class=entry-footer><span title='2025-05-04 10:00:00 +0800 +0800'>May 4, 2025</span>&nbsp;·&nbsp;<span>1 min</span></footer><a class=entry-link aria-label="post link to 策略解析：BollChannelStrategy (布林带通道突破)" href=https://allenhsu6.github.io/posts/strategies/boll_channel_strategy/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>策略解析：AtrRsiStrategy (ATR波动率结合RSI)</h2></header><div class=entry-content><p>源码文件：vnpy_ctastrategy.strategies.atr_rsi_strategy
1. 策略概述 AtrRsiStrategy 是一个结合了 波动率 (ATR) 和 动量 (RSI) 的趋势突破策略。 它的核心思想是：只有在市场波动率足够大（ATR 处于高位）时，才去交易 RSI 的突破信号。这是一种典型的“过滤器”思想，旨在减少 RSI 在低波动震荡市中的假突破磨损。
基类：CtaTemplate 核心指标：ATR (Average True Range), RSI (Relative Strength Index) 风控机制：百分比移动止损 (Trailing Stop) 2. 核心参数与变量 参数名 默认值 含义 atr_length 22 计算 ATR 的窗口周期 atr_ma_length 10 计算 ATR 均线的窗口周期 rsi_length 5 计算 RSI 的窗口周期（非常灵敏） rsi_entry 16 RSI 入场阈值偏移量 (50 ± 16) trailing_percent 0.8 移动止损百分比 (0.8%) 3. 策略逻辑详解 3.1 过滤器：ATR 波动率判断 策略首先计算 ATR 值及其移动平均线 (MA)。
1 2 3 atr_array = am.atr(self.atr_length, array=True) self.atr_value = atr_array[-1] self.atr_ma = atr_array[-self.atr_ma_length:].mean() 入场前提：self.atr_value > self.atr_ma
...</p></div><footer class=entry-footer><span title='2025-05-03 10:00:00 +0800 +0800'>May 3, 2025</span>&nbsp;·&nbsp;<span>2 min</span></footer><a class=entry-link aria-label="post link to 策略解析：AtrRsiStrategy (ATR波动率结合RSI)" href=https://allenhsu6.github.io/posts/strategies/atr_rsi_strategy/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://allenhsu6.github.io/categories/%E7%AD%96%E7%95%A5%E8%A7%A3%E6%9E%90/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://allenhsu6.github.io/>Xu'Log</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>